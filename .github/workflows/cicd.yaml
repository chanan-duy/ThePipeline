name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  issues: write
  pull-requests: write
  checks: write

env:
  IMAGE_NAME: chananduy/thepipeline
  DOTNET_VERSION: '10.0.x'
  SONAR_PROJECT_KEY: "chanan-duy_ThePipeline"
  SONAR_ORG: "chanan-duy"

jobs:
  notify-start:
    runs-on: ubuntu-latest
    steps:
      - name: Notify Telegram Start
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          format: html
          message: |
            ğŸš€ <b>Pipeline Started</b>
            
            ğŸ“‚ <b>Repo:</b> ${{ github.repository }}
            ğŸŒ¿ <b>Branch:</b> ${{ github.ref_name }}
            ğŸ‘¤ <b>User:</b> ${{ github.actor }}
            ğŸ’¬ <b>Commit:</b> ${{ github.event.head_commit.message }}
            
            ğŸ”— <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Live Log</a>

  versioning:
    needs: notify-start
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      semVer: ${{ steps.versioning.outputs.semVer }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v4.2.0
        with:
          versionSpec: '6.4.x'
      - name: Determine Version
        id: versioning
        uses: gittools/actions/gitversion/execute@v4.2.0

  build-test-scan:
    name: Build, Test, SAST & Pack
    needs: versioning
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install SonarQube scanner
        run: dotnet tool install --global dotnet-sonarscanner

      - name: SonarQube Begin
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          dotnet-sonarscanner begin /k:"${{ env.SONAR_PROJECT_KEY }}" /o:"${{ env.SONAR_ORG }}" /d:sonar.token="${{ secrets.SONAR_TOKEN }}" /d:sonar.host.url="https://sonarcloud.io"

      - name: Restore & Build
        run: |
          dotnet restore WebApi/WebApi/WebApi.csproj
          dotnet build WebApi/WebApi/WebApi.csproj --no-restore -c Release /p:Version=${{ needs.versioning.outputs.semVer }}

      - name: Unit Tests
        run: |
          dotnet test WebApi/WebApi.Test/WebApi.Test.csproj \
            --verbosity normal \
            --logger "trx;LogFileName=test_results.trx" \
            --results-directory ./TestResults

      - name: Publish Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ./TestResults/
          retention-days: 7

      - name: Test Report
        if: always()
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: 'TestResults/*.trx'

      - name: SonarQube End
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"

      - name: Publish for Release
        run: dotnet publish WebApi/WebApi/WebApi.csproj -c Release -o ./publish /p:Version=${{ needs.versioning.outputs.semVer }}

      - name: Zip Release Artifacts
        run: |
          cd ./publish
          zip -r ../webapi-release.zip .
          cd ..

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v5
        with:
          name: release-assets
          path: webapi-release.zip

  docker-build-push:
    name: Docker Build & Push
    needs: [ versioning, build-test-scan ]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: WebApi
          file: WebApi/WebApi/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ needs.versioning.outputs.semVer }}
            ${{ env.IMAGE_NAME }}:latest

  dast-analyze:
    name: DAST Analyze
    needs: [ versioning, docker-build-push ]
    runs-on: ubuntu-latest
    steps:
      - name: Start Container for DAST
        run: |
          docker run -d -p 8080:8080 --name test-app ${{ env.IMAGE_NAME }}:${{ needs.versioning.outputs.semVer }}
          sleep 10

      - name: OWASP ZAP Scan
        uses: zaproxy/action-baseline@v0.15.0
        with:
          target: 'http://localhost:8080'
          fail_action: false
          allow_issue_writing: false

  deploy-minikube:
    name: Deploy to Minikube (4 Zones)
    needs: [ versioning, dast-analyze ]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Setup Minikube
        uses: medyagh/setup-minikube@master
        with:
          memory: 4000m

      - name: Deploy to 4 Environments
        run: |
          helm lint ./chart

          namespaces="dev test stage prod"

          for nm in $namespaces; do
            kubectl create ns "$nm"
          done

          for nm in $namespaces; do
            echo Deploying helm chart to namespace "$nm" with image tag ${{ needs.versioning.outputs.semVer }}
            helm upgrade -i --namespace "$nm" dev --set image.tag=${{ needs.versioning.outputs.semVer }} mchart ./chart
          done

      - name: Verify Deployments
        run: |
          sleep 10
          kubectl get pods --all-namespaces

  create-release:
    name: Create Release
    needs: [ versioning, build-test-scan, dast-analyze, deploy-minikube ]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Download Artifacts
        uses: actions/download-artifact@v6
        with:
          name: release-assets

      - name: Build Changelog
        id: build_changelog
        uses: mikepenz/release-changelog-builder-action@v5
        with:
          mode: "COMMIT"
          configurationJson: |
            {
              "template": "#{{CHANGELOG}}",
              "categories": [
                {
                  "title": "## ğŸš€ Features",
                  "labels": ["feat", "feature"]
                },
                {
                  "title": "## ğŸ› Fixes",
                  "labels": ["fix", "bug", "hotfix"]
                },
                {
                  "title": "## ğŸ”’ Security",
                  "labels": ["sec", "security"]
                },
                {
                  "title": "## ğŸ›  Maintenance & Ops",
                  "labels": ["chore", "ci", "build", "refactor", "perf", "style"]
                },
                {
                  "title": "## ğŸ§ª Testing",
                  "labels": ["test"]
                },
                {
                  "title": "## ğŸ“¦ Other Changes",
                  "labels": []
                }
              ],
              "label_extractor": [
                {
                  "pattern": "^(build|chore|ci|docs|feat|fix|perf|refactor|revert|style|test){1}(\\([\\w\\-\\.]+\\))?(!)?: ([\\w ])+([\\s\\S]*)",
                  "on_property": "title",
                  "target": "$1"
                }
              ]
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.versioning.outputs.semVer }}
          name: Release v${{ needs.versioning.outputs.semVer }}
          body: |
            ## Changes in this version
            ${{ steps.build_changelog.outputs.changelog }}
          files: |
            webapi-release.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notify-finish:
    needs: [ versioning, build-test-scan, docker-build-push, dast-analyze, deploy-minikube, create-release ]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Notify Success
        if: ${{ needs.create-release.result == 'success' }}
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          format: html
          message: |
            âœ… <b>Pipeline SUCCESS!</b>
            
            ğŸ“¦ <b>Version:</b> <code>v${{ needs.versioning.outputs.semVer }}</code>
            ğŸ³ <b>Docker Image:</b> <code>${{ env.IMAGE_NAME }}:${{ needs.versioning.outputs.semVer }}</code>
            
            ğŸ”¹ <b>Status:</b>
            - Unit Tests: Passed âœ…
            - SonarQube: Scanned âœ…
            - Minikube: Deployed (4 zones) âœ…
            - DAST (ZAP): Checked âœ…
            
            ğŸ“ <a href="${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ needs.versioning.outputs.semVer }}">Open Release Notes</a>
            ğŸ”— <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Pipeline</a>

      - name: Notify Failure
        if: ${{ needs.create-release.result != 'success' }}
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          format: html
          message: |
            âŒ <b>Pipeline FAILED!</b>
            
            ğŸ“‚ <b>Repo:</b> ${{ github.repository }}
            ğŸŒ¿ <b>Branch:</b> ${{ github.ref_name }}
            ğŸ‘¤ <b>User:</b> ${{ github.actor }}
            
            <b>Failed Stage Check:</b>
            Build/Test: ${{ needs.build-test-scan.result }}
            Docker: ${{ needs.docker-build-push.result }}
            Deploy: ${{ needs.deploy-minikube.result }}
            
            ğŸ”— <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">ğŸ‘‰ Check Logs Here</a>
